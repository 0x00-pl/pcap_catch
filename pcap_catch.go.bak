// Package pcap is a wrapper around the pcap library.
package main


/*
#cgo LDFLAGS: -lpcap

#ifndef __CODE_FROM_C__
#define __CODE_FROM_C__

#include <pcap.h>

#include <net/if.h>
#include <netinet/in.h>
#include <linux/if_ether.h>
#include <pcap/vlan.h>
#include <linux/if_pppox.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/udp.h>

#include <string.h>
#include <stdio.h>
#include <arpa/inet.h>


#if 0
#define IF_DEBUG(x) x
#else
#define IF_DEBUG(x)
#endif

char last_error[256];
static inline const char *get_last_error(){
    return last_error;
}


typedef struct counter_decl{
    u_int64_t package;
    u_int64_t ip_package;
    u_int64_t tcp_package;
    u_int64_t tcp_port_80_package;
    u_int64_t tcp_link_package_foward;
    u_int64_t tcp_link_package_backward;
    u_int64_t http_bad_header;
    u_int64_t http_full_header;
    u_int64_t http_linked_header;
    u_int64_t http_request;
    u_int64_t cache_find;
    u_int64_t cache_update;
    u_int64_t cache_gc;
} counter_t;

#if 1
# define COUNTER_INC(member) (g_counter.member++)
#else
# define COUNTER_INC(x)
#endif
static counter_t g_counter = {0};

static void print_counter(counter_t *counter){
#define PRINT_COUNTER_MEMBER(member) \
    printf(#member ": %lu\n", counter->member)
    
    PRINT_COUNTER_MEMBER(package);
    PRINT_COUNTER_MEMBER(ip_package);
    PRINT_COUNTER_MEMBER(tcp_package);
    PRINT_COUNTER_MEMBER(tcp_port_80_package);
    PRINT_COUNTER_MEMBER(tcp_link_package_foward);
    PRINT_COUNTER_MEMBER(tcp_link_package_backward);
    PRINT_COUNTER_MEMBER(http_bad_header);
    PRINT_COUNTER_MEMBER(http_full_header);
    PRINT_COUNTER_MEMBER(http_linked_header);
    PRINT_COUNTER_MEMBER(http_request);
    PRINT_COUNTER_MEMBER(cache_find);
    PRINT_COUNTER_MEMBER(cache_update);
    PRINT_COUNTER_MEMBER(cache_gc);
    
#undef PRINT_COUNTER_MEMBER
}

#define SNAP_LEN 1518

struct pppoe_8863_8864{
    struct pppoe_hdr header;
    u_int16_t ppp_prorocol; // ETH_P_PPP_SES(8864) only
};

struct ip_with_options{
    struct iphdr header;
    u_char options[64];
};

typedef struct _pseudo_header
{
  unsigned int sourceIP;
  unsigned int destIP;
  unsigned char reserve;
  unsigned char protocol;
  unsigned short tcp_length;
} PSEUDO_HEADER;

#define PSEUDO_HEADER_LEN 12

struct tcp_with_options_header{
    struct tcphdr header;
    u_char options[64];
};

#define IP_LEN(iphdr_) ((iphdr_).ihl * 4)
#define TCP_LEN(tcphdr_) ((tcphdr_).doff * 4)

struct cap_headers{
    struct ethhdr eth;
    struct vlan_tag vlan;
    struct vlan_tag vlan1;
    struct pppoe_8863_8864 pppoe;
    struct ip_with_options ip;
    struct tcp_with_options_header tcp;
    u_char *payload;
    int payload_len;
};

static void print_mac(u_char mac[ETH_ALEN]){
    printf("%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
}

static void print_ethernet(struct ethhdr *header){
    printf("(struct ethhdr){\n");
    printf("    .h_dest = "); print_mac(header->h_dest); printf(",\n");
    printf("    .h_source = "); print_mac(header->h_source); printf(",\n");
    printf("    .h_proto = 0x%04x,\n", header->h_proto);
    printf("};\n");
}

static void print_vlan(struct vlan_tag *header){
    printf("(struct vlan_tag){\n");
    printf("    .vlan_tpid = 0x%04x,\n", header->vlan_tpid);
    printf("    .vlan_tci = 0x%04x,\n", header->vlan_tci);
    printf("};\n");
}

static void print_pppoe_hdr(struct pppoe_hdr *header){
    printf("(struct pppoe_hdr){\n");
    printf("    .ver = %x,\n", header->ver);
    printf("    .type = %x,\n", header->type);
    printf("    .code = %x,\n", header->code);
    printf("    .sid = 0x%04x,\n", header->sid);
    printf("    .length = %d,\n", header->length);
    printf("};\n");
}

static void print_pppoe_8864(struct pppoe_8863_8864 *header){
    print_pppoe_hdr(&header->header);
    printf("ppp_prorocol = 0x%04x;\n", header->ppp_prorocol);
}

static void print_iphdr(struct iphdr *header){
    printf("(struct iphdr){\n");
    printf("    .version = %x,\n", header->version);
    printf("    .ihl = %x,\n", header->ihl);
    printf("    .tos = %02x,\n", header->tos);
    printf("    .tot_len = %d,\n", header->tot_len);
    printf("    .id = 0x%04x,\n", header->id);
    printf("    .frag_off = %04x,\n", header->frag_off);
    printf("    .ttl = %d,\n", header->ttl);
    printf("    .protocol = 0x%02x,\n", header->protocol);
    printf("    .check = 0x%04x,\n", header->check);
    printf("    .saddr = %s,\n", inet_ntoa(*(struct in_addr*)&header->saddr));
    printf("    .daddr = %s,\n", inet_ntoa(*(struct in_addr*)&header->daddr));
    printf("};\n");
}

static void print_ip_with_options(struct ip_with_options *header){
  print_iphdr(&header->header);
  printf("options=...;\n");
}

static void print_tcphdr(struct tcphdr *header){
    printf("(struct tcphdr){\n");
    printf("    .source = %d,\n", header->source);
    printf("    .dest = %d,\n", header->dest);
    printf("    .seq = 0x%08x,\n", header->seq);
    printf("    .ack_seq = 0x%08x,\n", header->ack_seq);
    printf("    .doff = %x,\n", header->doff);
    printf("    .res1 = %x,\n", header->res1);
    printf("    .cwr = %x,\n", header->cwr);
    printf("    .ece = %x,\n", header->ece);
    printf("    .urg = %x,\n", header->urg);
    printf("    .ack = %x,\n", header->ack);
    printf("    .psh = %x,\n", header->psh);
    printf("    .rst = %x,\n", header->rst);
    printf("    .syn = %x,\n", header->syn);
    printf("    .fin = %x,\n", header->fin);
    printf("    .window = 0x%04x,\n", header->window);
    printf("    .check = 0x%04x,\n", header->check);
    printf("    .urg_ptr = 0x%04x,\n", header->urg_ptr);
    printf("};\n");
}

static void print_tcp_with_options(struct tcp_with_options_header *header){
  print_tcphdr(&header->header);
  printf("options=...;\n");
}

#define NTOHL(x) x = ntohl(x)
#define NTOHS(x) x = ntohs(x)

static void ip_net_order(struct ip_with_options *header){
    NTOHS(header->header.tot_len);
    NTOHS(header->header.id);
    NTOHS(header->header.frag_off);
    NTOHS(header->header.check);
}

static void tcp_net_order(struct tcp_with_options_header *header){
    NTOHS(header->header.source);
    NTOHS(header->header.dest);
    NTOHL(header->header.seq);
    NTOHL(header->header.ack_seq);
    NTOHS(header->header.window);
    NTOHS(header->header.check);
    NTOHS(header->header.urg_ptr);
}

static int decode_ethernet(u_char *packet, u_int paclen, struct ethhdr *header){
    memcpy(header, packet, ETH_HLEN);
    NTOHS(header->h_proto);
    return 0;
}
static int decode_vlan(u_char *packet, u_int paclen, struct vlan_tag *header){
    memcpy(header, packet, VLAN_TAG_LEN);
    NTOHS(header->vlan_tpid);
    NTOHS(header->vlan_tci);
    return 0;
}
static int decode_pppoe_8864(u_char *packet, u_int paclen, struct pppoe_8863_8864 *header){
    memcpy(header, packet, PPPOE_SES_HLEN);
    NTOHS(header->header.sid);
    NTOHS(header->header.length);
    NTOHS(header->ppp_prorocol);
    return 0;
}
static int decode_ip(u_char *packet, u_int paclen, struct ip_with_options *header){
    struct iphdr *ip = (struct iphdr*) packet;
    size_t size_ip = ip->ihl * 4;
    bzero(header->options, 64);
    memcpy(header, packet, size_ip);
    ip_net_order(header);
    return 0;
}
static int decode_tcp(u_char *packet, u_int paclen, struct tcp_with_options_header *header){
    struct tcphdr *tcp = (struct tcphdr*) packet;
    size_t size_tcp = tcp->doff * 4;
    bzero(header->options, 64);
    memcpy(&header->header, packet, size_tcp);
    tcp_net_order(header);
    return 0;
}

static int decode(u_char *packet, u_int paclen, struct cap_headers *headers){
#define POP_HEADER(size) packet+=size; paclen-=size;
    u_int16_t proto;
    decode_ethernet(packet, paclen, &headers->eth);
    POP_HEADER(ETH_HLEN);
    IF_DEBUG(print_ethernet(&headers->eth));
    proto = headers->eth.h_proto;
    
    if(proto == ETH_P_8021Q){
        decode_vlan(packet, paclen, &headers->vlan);
        POP_HEADER(VLAN_TAG_LEN);
        IF_DEBUG(print_vlan(&headers->vlan));
        proto = headers->vlan.vlan_tci;
    }
    
    if(proto == ETH_P_8021Q){
        decode_vlan(packet, paclen, &headers->vlan1);
        POP_HEADER(VLAN_TAG_LEN);
        IF_DEBUG(print_vlan(&headers->vlan1));
        proto = headers->vlan1.vlan_tci;
    }
    
    if(proto == ETH_P_PPP_SES){
        decode_pppoe_8864(packet, paclen, &headers->pppoe);
        POP_HEADER(PPPOE_SES_HLEN);
        IF_DEBUG(print_pppoe_8864(&headers->pppoe));
        proto = ETH_P_IP;
    }
    
    // assert(proto == ETH_P_IP)
    if(proto != ETH_P_IP){
        sprintf(last_error, "[error][decode]: unknow proto.\n");
        return -1;
    }
    COUNTER_INC(ip_package);
    
    decode_ip(packet, paclen, &headers->ip);
    size_t size_ip = headers->ip.header.ihl * 4;
    POP_HEADER(size_ip);
    IF_DEBUG(print_ip_with_options(&headers->ip));
    
    size_t size_tcp;
    switch(headers->ip.header.protocol){
    case IPPROTO_TCP:
        COUNTER_INC(tcp_package);
        decode_tcp(packet, paclen, &headers->tcp);
        size_tcp = headers->tcp.header.doff * 4;
        POP_HEADER(size_tcp);
        IF_DEBUG(print_tcp_with_options(&headers->tcp));
        headers->payload = packet;
        headers->payload_len = headers->ip.header.tot_len - (size_ip+size_tcp);
        break;
    default:
        sprintf(last_error, "[error][decode][ip]: unknow proto.\n");
        return -1;
    }
    return 0;
#undef POP_HEADER
}

#undef NTOHL
#undef NTOHS

extern void gocallback(void* func, void* args, char *tcp_payload, int length, void* extra);
struct got_packet_args_t{
  void* callback;
  void* callback_args;
};





static void got_packet(u_char *uargs, const struct pcap_pkthdr *header, const u_char *packet){
    COUNTER_INC(package);
    struct got_packet_args_t* args = (struct got_packet_args_t*)uargs;
    struct cap_headers cap_h;
    if(decode((u_char*)packet, header->caplen, &cap_h) == -1){
        return;
    }
    // print source and destination IP addresses
    IF_DEBUG(printf("       From: %s\n", inet_ntoa(*(struct in_addr*)&cap_h.ip.header.saddr)));
    IF_DEBUG(printf("         To: %s\n", inet_ntoa(*(struct in_addr*)&cap_h.ip.header.daddr)));
    if(cap_h.ip.header.protocol != IPPROTO_TCP){
      IF_DEBUG(printf("   Protocol: Not TCP.\n"));
      return;
    }
    IF_DEBUG(printf("   Src port: %d\n", cap_h.tcp.header.source));
    IF_DEBUG(printf("   Dst port: %d\n", cap_h.tcp.header.dest));

    if(cap_h.tcp.header.source==80 || cap_h.tcp.header.dest==80){
        COUNTER_INC(tcp_port_80_package);
    }

    //printf("---payload[%d]---\n%s", cap_h.payload_len, cap_h.payload);
    gocallback(args->callback, args->callback_args, cap_h.payload, cap_h.payload_len, NULL);
    
}

static void capture_n(int num_packets, const char *dev, const char *filter_exp,
               void* tcp_callback, void* cb_args){
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle;
    struct bpf_program fp;
    bpf_u_int32 mask;
    bpf_u_int32 net;

    
    if (dev == NULL) {
        dev = pcap_lookupdev(errbuf);
    }
    if (dev == NULL) {
        fprintf(stderr, "Couldn't find default device: %s\n", errbuf);
        return;
    }

    if(filter_exp==NULL){
        filter_exp = "ip and tcp dst port 80 and (ip[2:2]>80)";
    }

    // get network number and mask associated with capture device
    if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
       fprintf(stderr, "Couldn't get netmask for device %s: %s\n",
            dev, errbuf);
        net = 0;
        mask = 0;
    }

    handle = pcap_open_live(dev, SNAP_LEN, 1, 1000, errbuf);
    if(handle==NULL){
       fprintf(stderr, "Couldn't open live for device %s: %s\n",
            dev, errbuf);
       return;
    }
    if (pcap_datalink(handle) != DLT_EN10MB) {
        fprintf(stderr, "%s is not an Ethernet\n", dev);
        return;
    }


    if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
        fprintf(stderr, "Couldn't parse filter %s: %s\n",
            filter_exp, pcap_geterr(handle));
        return;
    }

    if (pcap_setfilter(handle, &fp) == -1) {
        fprintf(stderr, "Couldn't install filter %s: %s\n",
            filter_exp, pcap_geterr(handle));
        return;
    }

    struct got_packet_args_t got_packet_args = {
        .callback = tcp_callback,
        .callback_args = cb_args
    };
    printf("starting capture...\n");
    pcap_loop(handle, num_packets, got_packet, (u_char*)&got_packet_args);

    pcap_freecode(&fp);
    pcap_close(handle);

    printf("\nCapture complete.\n");
    print_counter(&g_counter);
}

#endif

*/
import "C"

import (
//	"errors"
	"unsafe"
	"fmt"
)


//typedef void tcp_callback_t(void* args, u_char *tcp_payload, int length, void* extra);

//export gocallback
func gocallback(f unsafe.Pointer, args unsafe.Pointer, tcp_payload *C.char, length C.int, extra unsafe.Pointer){
    (*(*func(unsafe.Pointer, *C.char, C.int, unsafe.Pointer))(unsafe.Pointer(&f)))(args, tcp_payload, length, extra)
}



func print_payload(args unsafe.Pointer, tcp_payload *C.char, length C.int, extra unsafe.Pointer){
  fmt.Println(C.GoString(tcp_payload));
}

var print_payload_cb = print_payload
func main() {
  cb := (*(*unsafe.Pointer)(unsafe.Pointer(&print_payload_cb)))
  C.capture_n(10, nil, nil, cb, nil)
}






